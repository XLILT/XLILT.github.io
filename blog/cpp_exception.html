<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="../stylesheets/normalize.css" media="screen">
    <link rel="stylesheet" type="text/css" href="../stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="../stylesheets/github-light.css" media="screen">
    <title>C++异常总结</title>
</head>

<body>
<section class="main-content">
<pre>
    请先看下面一段C++代码片段
    <code>
        mutex.lock();
        f();
        mutex.unlock();
    </code>
    对于上面一段代码，f()需要同步。于是执行前进行加锁操作，执行后解锁。这个一眼看去逻辑很正常。
    那么问题在哪儿呢？
    异常!
    对于C++的异常，熟悉的朋友可能知道对于可能抛出异常的接口调用时，需要用
    <code>
        try
        {
        }catch()
        {
        }
    </code>
    进行捕获异常。那么问题是对于一些接口我们有时候并不知道它是否会抛出异常。

    <b>但是一旦抛出异常，那么当前函数将终止执行后续代码片段。
    并且将异常根据函数调用栈层层返回，直到有一层进行捕获或者终止程序运行。</b>
    所有上面的代码，如果f()执行过程中抛出异常，那么<b>mutex.unlock()将不会被执行。</b>

    改进方法：利用栈上对象自动回收的机制，让系统进行自动加锁解锁操作。
    <code>
        class A
        {
        public:
            A() { mutex.lock(); }
            ~A() { mutex.unlock(); }
        };

        {
            A guard;
            f();
        }
    </code>
    当代码执行到大括号里面时，构造gurad对象进行加锁操作。当执行完f()离开大括号，析构guard对象，解锁。
    上面的代码即使f()里面抛出异常，一样会将加锁解锁完整闭环执行完。
</pre>
</section>
</body>

</html>
