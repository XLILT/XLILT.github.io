<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>C++内联函数</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>

    <section class="main-content">

<a id="2关于c内联函数" class="anchor" href="#2%E5%85%B3%E4%BA%8Ec%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>2、关于C++内联函数</h5>

<pre>
    渣书上面能找到的这里就不提了。
这里要说的是，当在头文件中声明成员函数，却在多个实现文件中实现（均实现为
inline函数）的情况。
这里存在2个问题：
（1）、编译器是否会报告重复定义或者找不到实现？
    针对 gcc 版本 4.4.7 20120313 (Red Hat 4.4.7-4) (GCC)，测试结果如下。
    首先，绝对不会报告重复定义错误。
    其次，有可能报告找不到实现。

（2）、如果不会重复定义，那么TMD那到底会使用哪个或者哪些实现呢？
    根据情况而定。
    看到这里，是不是有种感觉这是在逗你玩的感觉。并非。我的测试demo表明，你实现
inline的位置，并非为绑定具体实现到声明的位置。
他（编译器）会在按连接目标文件的次序，当连接到第一个使用该函数的目标文件，从该
文件中查找并绑定该函数。之后使用该函数，无论  是否出现其他实现，均不会影响该绑定。
    按照此原则，若第一次出现使用该函数时，对应目标文件中无实现，则会报告找不到
实现（基础知识嘛，对吧）。


    补充一点关于"const char *”知识。
    （1）头文件中可以定义非静态常量，不会出现重复定义错误。编译器会进行折叠优化。
    （2）可以通过string.c_str()作为函数返回值（const char *），类型。该指针不会随着string对象析构而失效。编译器进行常量优化。
</pre>

    </section>


  </body>
</html>
